"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.__esModule = true;
exports.default = fetchLocalChanges;
exports.hasUnsyncedChanges = hasUnsyncedChanges;

var _rambdax = require("rambdax");

var _fp = require("../../utils/fp");

var Q = _interopRequireWildcard(require("../../QueryDescription"));

var _Schema = require("../../Schema");

var _helpers = require("./helpers");

// NOTE: Two separate queries are faster than notEq(synced) on LokiJS
var createdQuery = Q.where((0, _Schema.columnName)('_status'), 'created');
var updatedQuery = Q.where((0, _Schema.columnName)('_status'), 'updated');

function fetchLocalChangesForCollection(collection) {
  return new Promise(function ($return, $error) {
    var createdRecords, updatedRecords, deletedRecords, changeSet, changedRecords;
    return Promise.resolve(Promise.all([collection.query(createdQuery).fetch(), collection.query(updatedQuery).fetch(), collection.database.adapter.getDeletedRecords(collection.table)])).then(function ($await_1) {
      try {
        [createdRecords, updatedRecords, deletedRecords] = $await_1;
        changeSet = {
          created: [],
          updated: [],
          deleted: deletedRecords
        };
        // TODO: It would be best to omit _status, _changed fields, since they're not necessary for the server
        // but this complicates markLocalChangesAsDone, since we don't have the exact copy to compare if record changed
        // TODO: It would probably also be good to only send to server locally changed fields, not full records
        // perf-critical - using mutation
        createdRecords.forEach(function (record) {
          changeSet.created.push(Object.assign({}, record._raw));
        });
        updatedRecords.forEach(function (record) {
          changeSet.updated.push(Object.assign({}, record._raw));
        });
        changedRecords = createdRecords.concat(updatedRecords);
        return $return([changeSet, changedRecords]);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

var extractChanges = (0, _rambdax.map)(function ([changeSet]) {
  return changeSet;
});
var extractAllAffectedRecords = (0, _rambdax.pipe)(_rambdax.values, (0, _rambdax.map)(function ([, records]) {
  return records;
}), _fp.unnest);

function fetchLocalChanges(db) {
  (0, _helpers.ensureActionsEnabled)(db);
  return db.action(function () {
    return new Promise(function ($return, $error) {
      var changes;
      return Promise.resolve((0, _rambdax.promiseAllObject)((0, _rambdax.map)(fetchLocalChangesForCollection, db.collections.map))).then(function ($await_2) {
        try {
          changes = $await_2;
          // TODO: deep-freeze changes object (in dev mode only) to detect mutations (user bug)
          return $return({
            // $FlowFixMe
            changes: extractChanges(changes),
            affectedRecords: extractAllAffectedRecords(changes)
          });
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }, $error);
    });
  }, 'sync-fetchLocalChanges');
}

function hasUnsyncedChanges(db) {
  (0, _helpers.ensureActionsEnabled)(db); // action is necessary to ensure other code doesn't make changes under our nose

  return db.action(function () {
    return new Promise(function ($return, $error) {
      var collections, hasUnsynced, unsyncedFlags;
      collections = (0, _rambdax.values)(db.collections.map);

      hasUnsynced = function (collection) {
        return new Promise(function ($return, $error) {
          var created, updated, deleted;
          return Promise.resolve(collection.query(createdQuery).fetchCount()).then(function ($await_3) {
            try {
              created = $await_3;
              return Promise.resolve(collection.query(updatedQuery).fetchCount()).then(function ($await_4) {
                try {
                  updated = $await_4;
                  return Promise.resolve(db.adapter.getDeletedRecords(collection.table)).then(function ($await_5) {
                    try {
                      deleted = $await_5;
                      return $return(0 < created + updated + deleted.length);
                    } catch ($boundEx) {
                      return $error($boundEx);
                    }
                  }, $error);
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }, $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        });
      };

      return Promise.resolve((0, _fp.allPromises)(hasUnsynced, collections)).then(function ($await_6) {
        try {
          unsyncedFlags = $await_6;
          return $return((0, _rambdax.any)(_rambdax.identity, unsyncedFlags));
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }, $error);
    });
  }, 'sync-hasUnsyncedChanges');
}